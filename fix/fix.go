// Copyright 2013 Richard Lehane. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package fixxml repairs invalid XML files.
//
// Written to clean up generic XML files generated by databases & that contain invalid entities.
//
// TODO: namespaces, attributes (currently only handles XML files that are all elements)
//
// Example:
//	reader := strings.NewReader("<dodgy><hello>Richa&rd</hello><richard.lehane@gmail.com></dodgy>")
//	writer := new(bytes.Buffer)
//	error := fixxml.Fixxml(reader, writer)
//	if writer.String() == "<dodgy><hello>Richa&amp;rd</hello>&lt;richard.lehane@gmail.com&gt;</dodgy>" {
//		fmt.Print("Thanks, I've been Fixxmled!")
//	}
package fix

import (
	"bufio"
	"bytes"
	"encoding/xml"
	"io"
	"strings"
)

const (
	content_mode = iota
	tag_mode
)

// A tree of valid element names
type name struct {
	gotos [256]*name
	end   bool
}

func (ln *name) add(seq []byte) {
	curr := ln
	for _, b := range seq {
		if nxt, _ := curr.next(b); nxt != nil {
			curr = nxt
		} else {
			ln = new(name)
			curr.gotos[b] = ln
			curr = ln
		}
	}
	curr.end = true
}

func (ln *name) next(b byte) (*name, bool) {
	next := ln.gotos[b]
	if next == nil {
		return nil, false
	}
	return next, next.end
}

func (ln *name) traverse() chan string {
	strs := make(chan string)
	nms := make([]byte, 0)
	var fn func(*name, []byte)
	fn = func(n *name, b []byte) {
		if n.end {
			strs <- string(b)
		}
		for i, n := range n.gotos {
			if n != nil {
				c := append(b, byte(i))
				fn(n, c)
			}
		}
	}
	go func() {
		fn(ln, nms)
		close(strs)
	}()
	return strs
}

func (ln *name) String() string {
	var strs string

	for str := range ln.traverse() {
		strs += str + " "
	}
	return strs
}

// Returns the root node of a tree of valid element names
func names(rdr io.Reader) *name {
	var n = new(name)

	ns := make(map[string]bool)

	decoder := xml.NewDecoder(rdr)
	decoder.Strict = false

	for tok, err := decoder.RawToken(); err != io.EOF; tok, err = decoder.RawToken() {
		// if it breaks, try again!
		if err != nil {
			decoder = xml.NewDecoder(rdr)
			decoder.Strict = false
			continue
		}
		switch el := tok.(type) {
		case xml.StartElement:
			if _, ok := ns[el.Name.Local]; !ok {
				ns[el.Name.Local] = false
			}
		case xml.EndElement:
			if _, ok := ns[el.Name.Local]; ok {
				ns[el.Name.Local] = true
			}
		}
	}
	for k, v := range ns {
		if v {
			n.add([]byte(k))
		}
	}
	// add the XML declaration to the list of valid names (a bit of a hack)
	n.add([]byte("?xml version=\"1.0\"?"))
	return n
}

// Reads invalid XML and writes clean XML
func Fix(rdr io.Reader, out io.Writer) error {
	rs, ok := rdr.(io.ReadSeeker)
	if !ok {
		var cpy bytes.Buffer
		if _, err := io.Copy(&cpy, rdr); err != nil {
			return err
		}
		rs = bytes.NewReader(cpy.Bytes())
	}
	root := names(rs)
	if _, err := rs.Seek(0, 0); err != nil {
		return err
	}

	return root.clean(rs, out)
}

// Useful for debugging. The name structure has a String() method.
func Names(rdr io.Reader) *name {
	root := names(rdr)
	return root
}

type tag struct {
	buf   *bytes.Buffer
	whole bool
	last  byte
	root  *name
	cur   *name
}

func newTag(nm *name) *tag {
	return &tag{buf: new(bytes.Buffer), root: nm, cur: nm}
}

func (t *tag) mustWrite(content *bytes.Buffer) {
	if _, err := content.Write(t.buf.Bytes()); err != nil {
		panic(err)
	}
	t.buf.Reset()
	t.cur = t.root
}

func mustWriteByte(buf *bytes.Buffer, c byte) {
	if err := buf.WriteByte(c); err != nil {
		panic(err)
	}
}

// Reads invalid XML and applies the tree of valid element names in order to escape all character content.
func (root *name) clean(rdr io.Reader, out io.Writer) (err error) {
	// tidy up error handling by using the panic-defer-recover convention
	defer func() {
		if r := recover(); r != nil {
			err = r.(error)
		}
	}()

	content := new(bytes.Buffer)
	tag := newTag(root)

	in, ok := rdr.(io.ByteReader)
	if !ok {
		in = bufio.NewReader(rdr)
	}

	var c byte
	mode := content_mode

	for c, err = in.ReadByte(); err == nil; c, err = in.ReadByte() {
		switch c {
		case '<':
			if mode == tag_mode {
				tag.mustWrite(content)
				mustWriteByte(tag.buf, c)
			} else {
				mode = tag_mode
				mustWriteByte(tag.buf, c)
			}
		case '/':
			if mode == tag_mode {
				if tag.last == '<' || tag.whole {
					mustWriteByte(tag.buf, c)
				} else {
					tag.mustWrite(content)
					mustWriteByte(content, c)
					mode = content_mode
				}
			} else {
				mustWriteByte(content, c)
			}
		case '>':
			if mode == tag_mode {
				if tag.whole {
					if content.Len() > 0 {
						if content.Len() < 10 {
							str := strings.TrimSpace(content.String())
							if len(str) < 1 {
								if _, e := out.Write(content.Bytes()); e != nil {
									return e
								}
							} else {
								if e := xml.EscapeText(out, content.Bytes()); e != nil {
									return e
								}
							}
						} else {
							if e := xml.EscapeText(out, content.Bytes()); e != nil {
								return e
							}
						}
						content.Reset()
					}
					mustWriteByte(tag.buf, c)
					if _, e := out.Write(tag.buf.Bytes()); e != nil {
						return e
					}
					tag.buf.Reset()
					tag.cur = tag.root
					tag.whole = false
				} else {
					tag.mustWrite(content)
					mustWriteByte(content, c)
				}
				mode = content_mode
			} else {
				mustWriteByte(content, c)
			}
		default:
			if mode == tag_mode {
				tag.cur, tag.whole = tag.cur.next(c)
				if tag.cur != nil {
					mustWriteByte(tag.buf, c)
				} else {
					tag.mustWrite(content)
					mustWriteByte(content, c)
					mode = content_mode
				}
			} else {
				mustWriteByte(content, c)
			}
		}
		tag.last = c
	}
	if err != io.EOF {
		return err
	}
	return nil
}
