// Copyright 2013 Richard Lehane. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Tool based on github.com/richardlehane/fixxml package.
//
// Written to clean up generic XML files generated by databases & that contain invalid entities.
//
// Example:
//   ./xmltool -in bad.xml -out good.xml
package main

import (
	"bufio"
	"flag"
	"github.com/richardlehane/fixxml"
	"log"
	"os"
)

var in = flag.String("in", "", "path to input XML file")
var out = flag.String("out", "", "path to output XML file")

func process(in, out string) error {
	inFile, err := os.Open(in)
	if err != nil {
		return err
	}
	rdr := bufio.NewReader(inFile)
	root := fixxml.Names(rdr)
	inFile.Close()

	inFile, err = os.Open(in)
	if err != nil {
		return err
	}
	rdr = bufio.NewReader(inFile)
	defer inFile.Close()

	outFile, err := os.Create(out)
	if err != nil {
		return err
	}
	defer outFile.Close()

	wrtr := bufio.NewWriter(outFile)

	err = root.Clean(rdr, wrtr)
	if err != nil {
		return err
	}
	return wrtr.Flush()
}

func main() {
	flag.Parse()
	if len(*in) < 1 {
		log.Fatal("Missing required argument: -in path_to_input_xml")
	}
	if len(*out) < 1 {
		log.Fatal("Missing required argument: -out path_to_output_xml")
	}
	err := process(*in, *out)
	if err != nil {
		log.Fatal(err)
	}
}
